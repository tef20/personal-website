---
import BaseHead from "../components/BaseHead.astro";
import { ViewTransitions } from "astro:transitions";
import { Image } from "astro:assets";
import InfoCard from "../components/InfoCard.astro";
import Link from "../components/Link.astro";

export const SITE_TITLE = "Astro Blog";
export const SITE_DESCRIPTION = "Welcome to my website!";
---

<html lang="en">
  <head>
    <BaseHead title={SITE_TITLE} description={SITE_DESCRIPTION} />
    <ViewTransitions />
  </head>
  <body>
    <!-- <Header title={SITE_TITLE} /> -->
    <aside>
      <InfoCard />
    </aside>
    <main>
      <Link href="/">
        <svg
          aria-hidden="true"
          focusable="false"
          width="17"
          height="17"
          xmlns="http://www.w3.org/2000/svg"
        >
          <path
            d="m.967 14.217 5.8-5.906-5.765-5.89L3.094.26l5.783 5.888L14.66.26l2.092 2.162-5.766 5.889 5.801 5.906-2.092 2.162-5.818-5.924-5.818 5.924-2.092-2.162Z"
            fill="#000"></path>
        </svg>
      </Link>
      <h1>Blog Article</h1>
      <article>
        <p>
          "Encapsulation" is a key concept in React that can help you minimize
          re-renders without relying on memoization! ### Use Case 1: Lowering
          State Imagine you've identified a component in your React application
          that's running lots of heavy re-renders! Every time its state changes,
          it re-renders all of its children, and one of those children takes
          500ms to render - <em>very greedy</em>! In this example, `input` is
          the only element in the `Parent` component that relies on the text
          state, so it might make sense to memoize `GreedyChild` and prevent it
          from re-rendering unnecessarily... ```jsx const MemoizedGreedyChild =
          memo(GreedyChild); ``` Problem solved? Kind of, but memoization is
          totally unnecessary if we can encapsulate `input` in its own
          component:
        </p>
        <p>
          "Encapsulation" is a key concept in React that can help you minimize
          re-renders without relying on memoization! ### Use Case 1: Lowering
          State Imagine you've identified a component in your React application
          that's running lots of heavy re-renders! Every time its state changes,
          it re-renders all of its children, and one of those children takes
          500ms to render - <em>very greedy</em>! In this example, `input` is
          the only element in the `Parent` component that relies on the text
          state, so it might make sense to memoize `GreedyChild` and prevent it
          from re-rendering unnecessarily... ```jsx const MemoizedGreedyChild =
          memo(GreedyChild); ``` Problem solved? Kind of, but memoization is
          totally unnecessary if we can encapsulate `input` in its own
          component:
        </p>
        <p>
          "Encapsulation" is a key concept in React that can help you minimize
          re-renders without relying on memoization! ### Use Case 1: Lowering
          State Imagine you've identified a component in your React application
          that's running lots of heavy re-renders! Every time its state changes,
          it re-renders all of its children, and one of those children takes
          500ms to render - <em>very greedy</em>! In this example, `input` is
          the only element in the `Parent` component that relies on the text
          state, so it might make sense to memoize `GreedyChild` and prevent it
          from re-rendering unnecessarily... ```jsx const MemoizedGreedyChild =
          memo(GreedyChild); ``` Problem solved? Kind of, but memoization is
          totally unnecessary if we can encapsulate `input` in its own
          component:
        </p>
      </article>
    </main>
    <style>
      article {
        max-height: 75vh;
        overflow-y: auto;
      }
    </style>
  </body>
</html>
