import { f as createComponent, r as renderTemplate, m as maybeRenderHead, u as unescapeHTML } from './astro_2c8dc02d.mjs';
import 'clsx';
import 'html-escaper';

const html = "<p>‚ÄúEncapsulation‚Äù is a key concept in React that can help you minimize re-renders without relying on memoization!</p>\n<h3 id=\"use-case-1-lowering-state\">Use Case 1: Lowering State</h3>\n<p>Imagine you‚Äôve identified a component in your React application that‚Äôs running lots of heavy re-renders! Every time its state changes, it re-renders all of its children, and one of those children takes 500ms to render - <em>very greedy</em>!</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" lang=\"jsx\"><code><span class=\"line\"><span style=\"color:#F97583\">function</span><span style=\"color:#B392F0\"> Parent</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  const</span><span style=\"color:#E1E4E8\"> [</span><span style=\"color:#79B8FF\">text</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">setText</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> useState</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">  return</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    &#x3C;></span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      &#x3C;</span><span style=\"color:#85E89D\">input</span><span style=\"color:#B392F0\"> value</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">{text} </span><span style=\"color:#B392F0\">onChange</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">{(</span><span style=\"color:#FFAB70\">e</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">=></span><span style=\"color:#B392F0\"> setText</span><span style=\"color:#E1E4E8\">(e.target.value)} /></span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      &#x3C;</span><span style=\"color:#79B8FF\">GreedyChild</span><span style=\"color:#E1E4E8\"> /></span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    &#x3C;/></span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  );</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre>\n<p>In this example, <code>input</code> is the only element in the <code>Parent</code> component that relies on the text state, so it might make sense to memoize <code>GreedyChild</code> and prevent it from re-rendering unnecessarily‚Ä¶</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" lang=\"jsx\"><code><span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> MemoizedGreedyChild</span><span style=\"color:#F97583\"> =</span><span style=\"color:#B392F0\"> memo</span><span style=\"color:#E1E4E8\">(GreedyChild);</span></span></code></pre>\n<p>Problem solved? Kind of, but memoization is totally unnecessary if we can encapsulate <code>input</code> in its own component:</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" lang=\"jsx\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">&#x3C;></span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  {</span><span style=\"color:#6A737D\">/* üëá state changes in here do not effect siblings */</span><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  &#x3C;</span><span style=\"color:#79B8FF\">EncapsulatedInput</span><span style=\"color:#E1E4E8\"> /></span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  {</span><span style=\"color:#6A737D\">/* üëá so no need to reach for memo here */</span><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  &#x3C;</span><span style=\"color:#79B8FF\">GreedyChild</span><span style=\"color:#E1E4E8\"> /></span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">&#x3C;/></span></span></code></pre>\n<br>\n<h3 id=\"use-case-2-raising-content\">Use Case 2: Raising Content</h3>\n<p>That was kind of kind of easy, but what if <code>GreedyChild</code> was nested under an element that <em>did</em> depend on this state?</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" lang=\"jsx\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">&#x3C;></span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  {</span><span style=\"color:#6A737D\">/* text cannot be lowered here.. */</span><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  &#x3C;</span><span style=\"color:#85E89D\">input</span><span style=\"color:#B392F0\"> value</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">{text} </span><span style=\"color:#B392F0\">onChange</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">{(</span><span style=\"color:#FFAB70\">e</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">=></span><span style=\"color:#B392F0\"> setText</span><span style=\"color:#E1E4E8\">(e.target.value)} /></span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  {</span><span style=\"color:#6A737D\">/* ...since className relies on it here */</span><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  &#x3C;</span><span style=\"color:#85E89D\">div</span><span style=\"color:#B392F0\"> className</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">{text}></span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    &#x3C;</span><span style=\"color:#79B8FF\">GreedyChild</span><span style=\"color:#E1E4E8\"> /></span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  &#x3C;/</span><span style=\"color:#85E89D\">div</span><span style=\"color:#E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">&#x3C;/></span></span></code></pre>\n<p>Surely we need <code>memo</code>, now?</p>\n<p>Again, encapsulation to the rescue! We can encapsulate the updating <code>className</code> logic inside its own container:</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" lang=\"jsx\"><code><span class=\"line\"><span style=\"color:#F97583\">function</span><span style=\"color:#B392F0\"> StatefulContainer</span><span style=\"color:#E1E4E8\">({ </span><span style=\"color:#FFAB70\">children</span><span style=\"color:#E1E4E8\"> }) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  const</span><span style=\"color:#E1E4E8\"> [</span><span style=\"color:#79B8FF\">text</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">setText</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> useState</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">  return</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    &#x3C;></span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      &#x3C;</span><span style=\"color:#85E89D\">input</span><span style=\"color:#B392F0\"> value</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">{text} </span><span style=\"color:#B392F0\">onChange</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">{(</span><span style=\"color:#FFAB70\">e</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">=></span><span style=\"color:#B392F0\"> setText</span><span style=\"color:#E1E4E8\">(e.target.value)} /></span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      &#x3C;</span><span style=\"color:#85E89D\">div</span><span style=\"color:#B392F0\"> className</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">{text}>{children}&#x3C;/</span><span style=\"color:#85E89D\">div</span><span style=\"color:#E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    &#x3C;/></span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  );</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre>\n<p>‚Ä¶and append <code>GreedyChild</code> via the <code>children</code> props:</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" lang=\"jsx\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">&#x3C;></span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  &#x3C;</span><span style=\"color:#79B8FF\">StatefulContainer</span><span style=\"color:#E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    &#x3C;</span><span style=\"color:#79B8FF\">GreedyChild</span><span style=\"color:#E1E4E8\"> /></span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  &#x3C;/</span><span style=\"color:#79B8FF\">StatefulContainer</span><span style=\"color:#E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">&#x3C;/></span></span></code></pre>\n<p>Now <code>GreedyChild</code> is isolated from re-renders that occur inside <code>StatefulContainer</code>!</p>\n<hr>\n<p>This is a riff on a classic short blog post by Dan Abramov - give it a read <a href=\"https://overreacted.io/before-you-memo/\">here</a>!</p>\n<p>For an excellent deep dive into React re-rendering, checkout Nadia Makarevich‚Äôs awesome blog <a href=\"https://www.developerway.com/posts/react-re-renders-guide\">here</a>.</p>";

				const frontmatter = {"title":"Encapsulation and Memoization","description":"Encapsulating your way out of React re-renders","pubDate":"Oct 3 2023","heroImage":"/blog-placeholder-3.jpg"};
				const file = "/home/chris/Documents/projects/personal-website/src/content/blog/classic-blogs-before-you-memo.md";
				const url = undefined;
				function rawContent() {
					return "\n\"Encapsulation\" is a key concept in React that can help you minimize re-renders without relying on memoization!\n\n### Use Case 1: Lowering State\n\nImagine you've identified a component in your React application that's running lots of heavy re-renders! Every time its state changes, it re-renders all of its children, and one of those children takes 500ms to render - <em>very greedy</em>!\n\n```jsx\nfunction Parent() {\n  const [text, setText] = useState(\"\");\n\n  return (\n    <>\n      <input value={text} onChange={(e) => setText(e.target.value)} />\n      <GreedyChild />\n    </>\n  );\n}\n```\n\nIn this example, `input` is the only element in the `Parent` component that relies on the text state, so it might make sense to memoize `GreedyChild` and prevent it from re-rendering unnecessarily...\n\n```jsx\nconst MemoizedGreedyChild = memo(GreedyChild);\n```\n\nProblem solved? Kind of, but memoization is totally unnecessary if we can encapsulate `input` in its own component:\n\n```jsx\n<>\n  {/* üëá state changes in here do not effect siblings */}\n  <EncapsulatedInput />\n  {/* üëá so no need to reach for memo here */}\n  <GreedyChild />\n</>\n```\n\n<br>\n\n### Use Case 2: Raising Content\n\nThat was kind of kind of easy, but what if `GreedyChild` was nested under an element that <em>did</em> depend on this state?\n\n```jsx\n<>\n  {/* text cannot be lowered here.. */}\n  <input value={text} onChange={(e) => setText(e.target.value)} />\n  {/* ...since className relies on it here */}\n  <div className={text}>\n    <GreedyChild />\n  </div>\n</>\n```\n\nSurely we need `memo`, now?\n\nAgain, encapsulation to the rescue! We can encapsulate the updating `className` logic inside its own container:\n\n```jsx\nfunction StatefulContainer({ children }) {\n  const [text, setText] = useState(\"\");\n\n  return (\n    <>\n      <input value={text} onChange={(e) => setText(e.target.value)} />\n      <div className={text}>{children}</div>\n    </>\n  );\n}\n```\n\n...and append `GreedyChild` via the `children` props:\n\n```jsx\n<>\n  <StatefulContainer>\n    <GreedyChild />\n  </StatefulContainer>\n</>\n```\n\nNow `GreedyChild` is isolated from re-renders that occur inside `StatefulContainer`!\n\n<hr>\n\nThis is a riff on a classic short blog post by Dan Abramov - give it a read [here](https://overreacted.io/before-you-memo/)!\n\nFor an excellent deep dive into React re-rendering, checkout Nadia Makarevich's awesome blog [here](https://www.developerway.com/posts/react-re-renders-guide).\n";
				}
				function compiledContent() {
					return html;
				}
				function getHeadings() {
					return [{"depth":3,"slug":"use-case-1-lowering-state","text":"Use Case 1: Lowering State"},{"depth":3,"slug":"use-case-2-raising-content","text":"Use Case 2: Raising Content"}];
				}

				const Content = createComponent((result, _props, slots) => {
					const { layout, ...content } = frontmatter;
					content.file = file;
					content.url = url;

					return renderTemplate`${maybeRenderHead()}${unescapeHTML(html)}`;
				});

export { Content, compiledContent, Content as default, file, frontmatter, getHeadings, rawContent, url };
